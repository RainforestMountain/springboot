项⽬介绍
背景
随着数字营销的兴起，企业越来越重视通过在线活动来吸引和留住客⼾。抽奖活动作为⼀种有效的营
销⼿段，能够显著提升⽤⼾参与度和品牌曝光率。于是我们就开发了以抽奖活动作为背景的Spring
Boot项⽬，通过这个项⽬提供⼀个全⾯、可靠、易于维护的抽奖平台，该平台将采⽤以下策略：
• 集成多种技术组件：利⽤MySQL、Redis、RabbitMQ等常⽤组件，构建⼀个稳定、⾼效、可扩展
的抽奖系统。
• 活动、奖品与⼈员管理：允许管理员创建配置抽奖活动；管理奖品信息；管理⼈员信息。
• 实现状态机管理：通过精⼼设计的状态机，精确控制活动及奖品状态的转换，提⾼系统的可控性和
可预测性。
• 保障数据⼀致性：通过事务管理和数据同步机制，确保数据的⼀致性和完整性。
• 加强安全性：实施安全措施，包括数据加密、⽤⼾认证，保护⽤⼾数据和系统安全。
• 降低维护成本：提供全⾯的⽇志记录和异常处理机制，简化问题诊断和系统维护。
• 提⾼扩展性：采⽤模块化设计与设计模式的使⽤，提⾼系统的灵活性和扩展性。


项目需求:
1. 包含管理员的注册与登录。
a. 注册包含：姓名、邮箱、⼿机号、密码
b. 登录包含两种⽅式：
i. 电话+密码登录；
ii. 电话+短信登录;  验证码获取
iii. 登录需要校验管理员⾝份。
2. ⼈员管理: 管理员⽀持创建普通⽤⼾, 查看⽤⼾列表
a. 创建普通⽤⼾：姓名，邮箱，⼿机号
b. ⼈员列表：⼈员id、姓名、⾝份（普通⽤⼾、管理员）
3. 管理端⽀持创建奖品、奖品列表展⽰功能。
a. 创建的奖品信息包含：奖品名称、描述、价格、奖品图(上传)
b. 奖品列表展⽰（可翻⻚）：奖品id、奖品图、奖品名、奖品描述、奖品价值（元）
4. 管理端⽀持创建活动、活动列表展⽰功能。
a. 创建的活动信息包含：
i. 活动名称
ii. 活动描述
iii. 圈选奖品：勾选对应奖品，并设置奖品等级（⼀⼆三等奖），及奖品数量
iv. 圈选⼈员：勾选参与抽奖⼈员
b. 活动列表展⽰（可翻⻚）：
i. 活动名称
ii. 描述iii. 活动状态：
1. 活动状态为进⾏中：点击 "活动进⾏中, 去抽奖" 按钮跳转抽奖⻚
2. 活动状态为已完成：点击 "活动已完成, 查看中奖名单" 按钮跳转抽奖⻚查看结果
5. 抽奖⻚⾯：
a. 对于进⾏中的活动，管理员才可抽奖。
b. 每轮抽奖的中奖⼈数跟随当前奖品数量。
c. 每个⼈只能中⼀次奖
d. 多轮抽奖，每轮抽奖有3个环节：展⽰奖品信息（奖品图、份数），⼈名闪动，停⽌闪动确定中
奖名单
i. 当前⻚展⽰奖品信息, 点击‘开始抽奖’按钮, 则跳转⾄⼈名闪动画⾯
ii. ⼈员闪动画⾯，点击’点我确定‘按钮，确认中奖名单。
iii. 当前⻚展⽰中奖名单, 点击‘已抽完，下⼀步’按钮, 若还有奖品未抽取, 则展⽰下⼀个奖品
信息, 否则展⽰全部中奖名单
iv. 点击’查看上⼀奖项‘按钮，展⽰上⼀个奖品信息
e. 对于抽奖过程中的异常情况，如抽奖过程中刷新⻚⾯，要保证抽取成功的奖项不能重新抽取。
i. 刷新⻚⾯后, 若当前奖品已抽完, 点击"开始抽奖",则直接展⽰当前奖品中奖名单
f. 如该抽奖活动已完成:
i. 展⽰所有奖项的全部中奖名单
ii. 新增"分享结果"按钮, 点击可复制当前⻚链接, 打开后隐藏其他按钮, 只展⽰活动名称与中奖
结果, 保留"分享结果" 按钮
6. 通知部分: 抽奖完成需以邮件和短信⽅式通知中奖者。
a. “Hi，xxx。恭喜你在xxx抽奖中获得⼀等奖：⼿机。中奖时间为：xx:xx。请尽快领取您的奖
品。”
7. 管理端涉及的所有⻚⾯, 包括抽奖⻚，需强制管理员登录后⽅可访问。
a. 未登录强制跳转登录⻚⾯



业务功能模块
• ⼈员业务模块：管理员注册、登录，及普通⽤⼾的创建。
• 活动业务模块：活动管理及活动状态管理。
• 奖品业务模块：奖品管理与奖品的分配。还包括奖品图的上传。
• 通知业务模块：发送短信、邮件等业务，例如验证码发送，中奖通知。
• 抽奖业务模块：完成抽奖动作，以及抽奖后的结果展⽰。
注：具体哪个模块完成哪些功能，在下⼀章展开讲解。这⾥我们只⽤知道分了哪些模块处理即可。
数据库设计
• ⽤⼾表：存储⽤⼾信息，如⽤⼾名、密码、邮箱等。
• 活动表：存储活动信息，如活动名称、描述、活动状态等。
• 奖品表：存储奖品信息，如奖品名称、奖品图等。
• 活动奖品关联表：存储⼀个活动下关联了哪些奖品。
• 活动⽤⼾关联表：存储⼀个活动下设置的参与⼈员。
• 中奖记录表：存储⼀个活动的中奖名单，如活动id，奖品id，中奖者id等。


代码编写顺序
一.通⽤处理模块
错误码, 通用返回结果, 序列化工具

数据持久层(Do), 服务器(DTO),  web层(Result)的返回结果还需要写个方法去进行转换,转换时使用的是stream流
传给web层和service层的参数可以相同,比如CreatePrizeParam, (返回DTO)
传给数据持久层的参数是对象和一些参数, 比如PrizeDo, (返回数字, 列表, 即Do)
传给数据库层次的参数是sql查询语句,由一些框架和api处理

二.用户模块
1.注册
1.1 敏感字段加密
⼀般来说，⽤⼾注册时，需要输⼊其账⼾密码及⼿机号，服务器应该将其保存起来，⽅便后续登录验
证。但仅从道德的⻆度来说，后端不应该以明⽂形式存储⽤⼾密码以及其他敏感信息。
• 从运维层⾯看，任何操作系统漏洞、基础⼯具漏洞的发⽣，都会导致密码泄露
• 从开发层⾯看，任何代码逻辑有漏洞、任何依赖库的漏洞都可能导致密码泄露
• 从管理层⾯看，任何⼀个有权限读取数据库的⼈，都能看到所有⽤⼾的密码
密码如何加密？
• 对称加密？
◦ ⽐如3DES、AES等算法，使⽤这种⽅式加密是可以通过解密来还原出原始密码的，当然前提
条件是需要获取到密钥。密钥很可能也会泄露，当然可以将⼀般数据和密钥分开存储、分开
管理，但要完全保护好密钥也是⼀件⾮常复杂的事情，所以这种⽅式并不是很好的⽅式。
• 哈希 yes
◦ 加密不可逆
◦ 彩虹表攻击
• 加盐哈希？加盐哈希是⽬前业界最常⻅的做法。
◦ ⽤⼾注册时，给他随机⽣成⼀段字符串，这段字符串就是盐（Salt）
◦ 把⽤⼾注册输⼊的密码和盐拼接在⼀起，叫做加盐密码
◦ 对加盐密码进⾏哈希，并把结果和盐都储存起来
  登录的时候,根据用户输入的密码和数据库对应的盐值拼接起来, 然后加盐哈希后, 与数据库存的字符串进行比对, 即数字签名的验证
⼿机号如何加密？
对称加密 yes
除了密码以外，⼿机号等信息也是重要的隐私数据。但⼿机号与密码不同：对于后端来说，永远不知
道密码的明⽂也不会对业务逻辑造成影响；⽽后端可能需要明⽂的⼿机号，在⼀些情况下给⽤⼾发送
短信。因此对于⼿机号这种信息，只能⽤相对安全的做法，即先对⼿机号进⾏对称加密，再将加密结果储存
在数据库⾥；使⽤时再⽤密钥解开。

加密⼯具
国产 Java⼯具类库 Hutool，对⽂件、流、加密解密、转码、正则、线程、XML 等 JDK ⽅法进⾏了封
装，开箱即⽤！


2. 登录
2.1 发送验证码
在我们的登录设计中，有⼀种登录⽅式为短信验证码登录，那么在登录前，就需要先获取验证码。验
证码服务使⽤阿⾥云提供的短信服务来完成

2.2 Redis 的配置与使⽤
详⻅《Redis 介绍与简单使⽤》⽂档
• RedisUtil ⼯具类实现

2.3 JWT令牌登录机制

2.4 管理员登录（两种⽅式）
1. 登陆⻚⾯把⽤⼾名密码提交给服务器.
2. 服务器端验证⽤⼾名密码是否正确, 如果正确, 服务器⽣成令牌, 下发给客⼾端.
3. 客⼾端把令牌存储起来(⽐如Cookie, local storage等), 后续请求时, 把token发给服务器
4. 服务器对令牌进⾏校验,  如果令牌正确, 进⾏下⼀步操作

还有统一的异常处理, 各自返回结果的转换

3.强制登录(拦截器设置)
当⽤⼾访问⾮登录注册⻚⾯时，例如抽奖⻚⾯，如果⽤⼾当前尚未登陆，我们希望⾃动跳转到登陆⻚
⾯, 通过验证令牌是否存在以及是否正确
3.1. 前端请求时, header 中统⼀添加 token (登录成功后后端会返回 token), 让后端去验证 ，格式如下
// 格式:
{
"user_token":"xxxxxxx"
}
// 例如：
$(document).ajaxSend(function (e, xhr, opt) {
var user_token = localStorage.getItem("user_token");
xhr.setRequestHeader("user_token", user_token);
});
ajaxSend() ⽅法在 AJAX 请求开始时执⾏函数
• event - 包含 event 对象
• xhr - 包含 XMLHttpRequest 对象
• options - 包含 AJAX 请求中使⽤的选项
3.2. 接着由于后端进⾏⽤⼾⾝份验证, 若不存在 token 或失效, 则失败返回

3.a. 添加拦截器
采⽤拦截器来完成校验 token 的合法性

3.b. 添加配置类
用来配置拦截器以及其他处理器
配置类在 Spring 框架中非常灵活，可以用于多种用途。除了配置拦截器之外，
还可以用于定义 Bean、配置数据源、事务管理器、JPA、Web 相关的 Bean、安全设置、
国际化、异步任务、定时任务、缓存、消息队列、邮件服务、文件上传、Web 客户端和日志等。
通过合理使用配置类，可以实现高度可配置和可扩展的 Spring 应用

4.用户管理
4.1 后台管理
admin.html
4.2 注册⽤⼾
与注册后端逻辑保持⼀致,
前端逻辑略微改变: 如果是管理员新增⽤⼾，完成后直接跳转到⽤列表⻚去

4.3 ⼈员列表展⽰

5.奖品模块
5.1图片上传

5.2. 创建奖品
[请求] /prize/create POST
param: {"prizeName":"吹⻛机","description":"吹⻛机","price":100}
prizePic: Obj-C.jpg (FILE)
[响应]
{
"code": 200,
"data": 17,
"msg": ""
}
5.3 奖品列表展⽰（翻⻚)

[请求] /prize/find-list?currentPage=1&pageSize=10 GET
[响应]
{
"code": 200,
"data": {
"total": 3,
"records": [
{
"prizeId": 17,
"prizeName": "吹⻛机",
"description": "吹⻛机",
"price": 100,
"imageUrl": "d11fa79c-9cfb-46b9-8fb6-3226ba1ff6d6.jpg"
},
{
"prizeId": 13,
"prizeName": "华为⼿机",
"description": "华为⼿机",
"price": 5000,
"imageUrl": "5a85034b-91b7-48fe-953d-67aef2bdcc2d.jpg"
},
{
"prizeId": 12,
"prizeName": "咖啡机","description": "家⽤咖啡机",
                   "price": 3000,
                   "imageUrl": "https://ts1.cn.mm.bing.net/th/id/RC.59493f741a4d956f354d241ec1034624?
                   rik=JpdNO%2bfC3NMONw&riu=http%3a%2f%2fcdn02.ehaier.com%2fproduct%2f5600fa6c1a0a
                   2ebc278b47e8_1200_1200.jpg&ehk=8MptQ5r5ILWiL4v%2f5mn3s0%2f1H05r1yp%2fL6feezFw89
                   Q%3d&risl=&pid=ImgRaw&r=0"
                   }
                   ]
                   },
                   "msg": ""
                   }


6.活动模块

6.1活动创建

[请求] /activity/create POST
{
"activityName": "抽奖测试",
"description": "年会抽奖活动",
"activityPrizeList": [
{
"prizeId": 13,
"prizeAmount": 1,
"prizeTiers": "FIRST_PRIZE"
},
{
"prizeId": 12,
"prizeAmount": 1,
"prizeTiers": "SECOND_PRIZE"
}
],
"activityUserList": [
{
"userId": 25,
"userName": "郭靖"
},
{
"userId": 23,
"userName": "杨康"
}
]
} [
响应]
{
"code": 200,
"data": {
"activityId": 23
},
"msg": ""
}
除了上面的信息, 还有关键的一点, 活动状态, 正在进行还是已经结束了

6.2.活动列表展⽰（翻⻚）

7.抽奖模块
7.1. 抽奖设计
抽奖过程是抽奖系统中最重要的核⼼环节，它需要确保公平、透明且⾼效。以下是详细的抽奖过程设
计：
1. 参与者注册与奖品建⽴
• 参与者注册：管理员通过管理端新增⽤⼾,  填写必要的信息，如姓名、联系⽅式等。
• 奖品建⽴：奖品需要提前建⽴好
2. 抽奖活动设置
• 活动创建：管理员在系统中创建抽奖活动，输⼊活动名称、描述、奖品列表等信息。
• 圈选⼈员: 关联该抽奖活动的参与者。
• 圈选奖品：圈选该抽奖活动的奖品，设置奖品等级、个数等。
• 活动发布：活动信息发布后，系统通过管理端界⾯展⽰活动列表。
3. 抽奖请求处理（重要）
• 随机抽取：前端随机选择后端提供的参与者，确保每次抽取的结果是公平的。
• 请求提交：在活动进⾏时，管理员可发起抽奖请求。请求包含活动ID、奖品ID和中奖⼈员等附加
信息。
• 消息队列通知：有效的抽奖请求被发送⾄MQ队列中，等待MQ消费者真正处理抽奖逻辑。
• 请求返回：抽奖的请求处理接⼝将不再完成任何的事情，直接返回。
4. 抽奖结果公布
• 前端展⽰：中奖名单通过前端随机抽取的⼈员，公布展⽰出来。5. 抽奖逻辑执⾏（重要）
• 消息消费：MQ消费者收到异步消息，系统开始执⾏以下抽奖逻辑。
6. 中奖结果处理（重要）
• 请求验证：
◦ 系统验证抽奖请求的有效性，如是否满⾜系统根据设定的规则（如奖品数量、每⼈中奖次数
限制等）等；
◦ 幂等性：若消息多发，已抽取的内容不能再次抽取
• 状态扭转：根据中奖结果扭转活动/奖品/参与者状态，如奖品是否已被抽取, ⼈员是否已中奖等。
• 结果记录：中奖结果被记录在数据库中，并同步更新 Redis 缓存。
7. 中奖者通知
• 通知中奖者：通知中奖者和其他相关系统（如邮件发送服务）。
• 奖品领取：中奖者根据通知中的指引领取奖品。
8. 抽奖异常处理
• 回滚处理：当抽奖过程中发⽣异常，需要保证事务⼀致性。
• 补救措施：抽奖⾏为是⼀次性的，因此异步处理抽奖任务必须保证成功，若过程异常，需采取补
救措施
技术实现细节
• 异步处理：提⾼抽奖性能，不影响抽奖流程，将抽奖处理放⼊队列中进⾏异步处理，且保证了幂
等性。
• 活动状态扭转处理：状态扭转会涉及活动及奖品等多横向维度扭转，不能避免未来不会有其他内
容牵扯进活动中，因此对于状态扭转处理，需要⾼扩展性（设计模式）与维护性。
• 并发处理：中奖者通知，可能要通知多系统，但相互解耦，可以设计为并发处理，加快抽奖效率
作⽤。
• 事务处理：在抽奖逻辑执⾏时，如若发⽣异常，需要确保数据库表原⼦性、事务⼀致性，因此要
做好事务处理。
通过以上流程，抽奖系统能够确保抽奖过程的公平性和⾼效性，同时提供良好的⽤⼾体验。⽽且还整
合了 Redis 和 MQ , 进⼀步提⾼系统的性能。

7.2. RabbitMQ 的配置与使⽤
创建一个配置类

7.3 抽奖请求处理
前端发送抽奖的结果请求, 后端响应抽奖是否成功
特殊在于 不经过Dao层, 数据库, 先直接返回抽奖的成功与否
并且抽奖操作其实在前端,

7.4. MQ 异步抽奖逻辑执⾏
消费 MQ 消息
• 消费者类 MqReceiver 实现


7.4.1请求验证（核对抽奖信息有效性）
校验什么？
• 校验是否存在活动奖品• 校验奖品数量是否⾜够中奖⼈数
• 校验活动有效性
• 校验抽取的奖品的有效性
• ....

7.4.2 状态转换
 活动/奖品/参与者状态转换设计
 . 初始状态：活动创建
 关键状态：创建活动后，会初始化 3 个基础状态 ：
 参与者未中奖（用户还没抽奖，或抽奖没中 ）
 奖品初始化（奖品刚录入，库存、规则已设置，等待被抽取 ）
 活动进行中（活动处于可参与状态，用户能发起抽奖 ）
 2. 抽奖触发状态扭转
 抽奖是状态变化的核心触发点，执行抽奖后，会根据结果改变不同对象的状态：
 情况 1：参与者中奖
 状态变化：
 “参与者未中奖” → “参与者中奖”（用户状态从 “未中奖” 变为 “中奖” ）
 “奖品初始化” → “奖品已被抽取”（奖品库存减 1，状态从 “待抽” 变为 “已抽” ）
 逻辑：中奖后，既改变用户的参与结果，也改变奖品的剩余状态，保证后续流程能正确判断 “谁中奖了、奖品还剩多少”。
 情况 2：参与者未中奖
 状态变化：
 仅 “参与者未中奖” 状态可能保持（或标记为 “参与过但未中奖”，具体看业务设计 ）
 奖品、活动状态不变（因为没中奖，不影响奖品库存和活动进行中状态 ）
 逻辑：未中奖时，主要更新用户参与记录，不干扰活动和奖品的可用状态。
 情况 3：奖品全部被抽完
 状态变化：
 当所有奖品都被抽中（即 “奖品已被抽取” 累计到总数 ），触发 → “奖品全部被抽完”
 接着，“活动进行中” → “活动已完成”（活动因奖品耗尽，无法再参与 ）
 逻辑：奖品是活动的核心资源，奖品抽完意味着活动目标达成，自动结束活动，避免用户无效参与。
 3. 状态扭转的意义
 数据一致性：确保 “用户参与结果”“奖品剩余数量”“活动可用状态” 三者联动，
 比如奖品抽完后活动关闭，防止超发奖品、重复抽奖。
 流程引导：通过状态变化，指引后续操作（比如活动关闭后不再接受抽奖请求，中奖后引导用户兑奖 ）。
 业务闭环：从 “活动创建 → 进行中 → 奖品消耗 → 活动结束”，
 状态扭转让整个抽奖流程有清晰的阶段划分，方便管理和监控。

解决⽅案
1. 策略模式（Strategy Pattern）:定义 AbstractActivityOperator 策列类，和其策略实现类
PrizeOperator、ActivityOperator 和 UserOperator。每个具体的操作类都实现了
AbstractActivityOperator 定义的接⼝，代表了不同的状态转换策略。
2. 责任链模式（Chain of Responsibility Pattern）: 定义 ActivityStatusManager 接⼝类， 在
ActivityStatusManagerImpl 实现中，通过遍历operatorMap 中的所有操作符（策略），并按照
⼀定的顺序执⾏，形成了⼀个责任链，每个操作符判断是否是⾃⼰的责任，如果是，则处理请
求。
责任链模式（Chain of Responsibility Pattern）是⼀种⾏为设计模式，它允许将⼀个请求沿着处理
者对象组成的链进⾏传递。每个处理者对象都有责任去处理请求，或者将它传递给链中的下⼀个处理
者。请求的传递⼀直进⾏，直到有⼀个处理者对象对请求进⾏了处理，或者直到链的末端仍未有处理
者处理该请求。
以下是责任链模式在 ActivityStatusManagerImpl 类中的实现细节：
1. 请求的创建：ActivityStatusConvertDTO statusConvertDTO 是请求对象，包含了状态转换所需
的所有信息。
2. 处理者对象：AbstractActivityOperator 及其⼦类 PrizeOperator 和 ActivityOperator 是处理者
对象，它们实现了 needConvert 和convertStatus ⽅法，⽤以判断是否需要处理请求以及执⾏处
理。
3. 责任链的维护：operatorMap 是⼀个包含所有处理者对象的映射，它按照 sequence() ⽅法返回
的顺序维护了责任链。
4. 请求的传递：在 processStatusConversion ⽅法中，通过迭代器遍历 operatorMap，对每个操作
符实例调⽤needConvert⽅法来判断是否需要由当前操作符处理请求。
5. 处理请求：如果 needConvert 返回true，则调⽤ convertStatus ⽅法来处理请求。
6. 终⽌责任链：⼀旦请求被某个操作符处理，迭代器中的该操作符将被移除（it.remove()），这防
⽌了请求被重复处理，并且终⽌了对该操作符的责任链。
7. 异常处理：如果在责任链中的任何点上请求处理失败（convertStatus返回false），则抛出异
常，这可以看作是责任链的终⽌。
通过这种⽅式，责任链模式允许系统在运⾏时根据请求的类型动态地选择处理者，⽽不需要修改其他
处理者的代码，从⽽提⾼了系统的灵活性和可维护性。

7.5 邮箱通知(多线程,并发处理)
当中奖结果被记录下来后，需要完成给中奖⽤⼾发送短信、邮件通知等⾏为，这俩⾏为相互独⽴，设
计为并发执⾏可以提⾼处理效率，减少响应时间。因为在处理消息队列中的消息时，通常希望尽快响
应和处理消息

7.6事务⼀致性--异常回滚
什么是事务？回答这个问题之前，我们先来看⼀个经典的场景：⽀付宝等交易平台的转账。假设⼩明
需要⽤⽀付宝给⼩红转账 100000 元，此时，⼩明帐号会少 100000 元，⽽⼩红帐号会多 100000 元。
如果在转账过程中系统崩溃了，⼩明帐号少 100000 元，⽽⼩红帐号⾦额不变，就会出⼤问题，因此这
个时候我们就需要使⽤事务了

这⾥，体现了事务⼀个很重要的特性：原⼦性。
事务的四个基本特性：原⼦性、⼀致性、隔离性、持久性。
• 原⼦性：即事务内的操作要么全部成功，要么全部失败，不会在中间的某个环节结束。
• ⼀致性：即使数据库在⼀个事务执⾏之前和执⾏之后，数据库都必须处于⼀致性状态。如果事务
执⾏失败，那么需要⾃动回滚到原始状态，换句话说，事务⼀旦提交，其他事务查看到的结果⼀
致，事务⼀旦回滚，其他事务也只能看到回滚前的状态。
• 隔离性：即在并发环境中，不同的事务同时修改相同的数据时，⼀个未完成事务不会影响另外⼀
个未完成事务。
• 持久性：即事务⼀旦提交，其修改的数据将永久保存到数据库中，其改变是永久性的。
在我们的场景中，MQ 消费的过程⾥，不仅仅修改了数据库表内容，还向 Redis 缓存中新增了很多热点
数据。例如扭转了奖品及活动的状态，还将中奖名单落⼊库中。那么在这个过程中，⼀旦出现异常，
我们必须要保证该事务的特性。

如何实现事务？⼀种常⽤的实现⽅案是 catch异常并实现回滚。

7.7 查看中奖者名单


7.8 查看活动详情
这是新增的分享结果按钮, 点击可复制当前页的链接, 打开后隐藏其他按钮,
只展示活动名称与中奖结果, 保留分享结果按钮

